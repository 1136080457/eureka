day_01:
	1.标识符不能以数字开头，标识符严格区分大小写，标识符的长度是没有长度限制的，关键字和保留字不能用于自定义的标识符；
	2.类名和接口的首字母大写，变量名和方法名首字母小写，包名全部小写，常量名单词之间加下划线分隔；
	3./* 单行注释 */   /** 文档注释 */  文档注释可以生成一个开发者文档
	4.Javadoc用法：Javadoc （-author -version等）-d 文件保存路径名 java源文件名.java
	5.变量名的命名规范：首单词小写，其他单词首字母大写，其他小写
	6.byte字节 8位(bit)  -128-127 。。。。。。
	7.小转大，自动转换;大转小，强制转换：小数据 =（小数据）大数据类型
	8.负数的二进制数最高位是1，正数的二进制数最高位是0;正数的补码是他本身，
	负数的二进制（补码）等于其绝对值的原码，再把原码变成反码（0变1,1变0），最后再加1；
	9.凡是byte、short、char数据类型在运算的时候都会自动转换成int类型的数据再运算!
	10.两个不同数据类型运算，结果取决于大的数据类型!
	11.计算机每次运算的时候只能取两个数据运算，任何数据类型的数据与字符串相加都是字符串类型！
	12.Java中取模（取余）运算，结果的符号取决于被除数的符号
	13.+=在编译的时候，Java编译器会强制转换，不需要我们手动转换
	14.==对于基本数据类型比较的是值是否一致，对于引用数据类型比较的是所对应的内存地址是否一致
	15.两个不同的数据类型可以进行比较，但是数据类型必须是兼容的
	16.^异或，两边结果都不同是true,其它为false
	&&短路与，当左边的表达式为false时，不会运算右边的，提高了效率;而&是两边都要运算
	||短路或，当左边的表达式为true时，不会运算右边的，提高了效率;而|是两边都要运算
	位运算符：直接操作二进制数,1看成true，0看成false;如果一个数^(异或)同一个数2次，结果任为原数!
	~取反，注意最高位是1，是补码，还要转换为原码，最后加上负号；
	17.移位运算：<<(左移，二进制全部向左移动一位，末位用0补齐),左移几位后的值等于原值乘以2的左移次方；
	>>(右移,如果操作数是正数，左边空位用0补；如果是负数，用1补)，右移的值等于该数除以2的右移次方数（取整）
	>>>无符号右移，不管操作数是正还是负数，左边的空位空位都用0补
day_02:
	1.switch语句使用的变量只能是byte、short、int、char、String和枚举,String是JDK7.0的时候开始支持的，case后面跟的数据必须是常		量switch语句一旦匹配上其中一个case,就执行对应的代码，执行完毕如果没有遇到break或结束switch的大括号，那么switch语句不再判断		，按照代码顺序从上往下执行所有的代码，直到遇到break或结束switch语句的大括号为止。(case后面只写枚举值，不能写枚举类.枚举值)
	2.for(初始化语句;判断语句;循环后的语句){循环体}；for( ; ; )，这是一个死循环
	3.转义字符: \b(退格);\t(制表符);\n(换行);\r(回车，把光标移动到一行的首位置上，后面的内容将替换前面的内容)；在Windows上操		作文件换行的时候需要用\r\n，其他系统只需要\n就可以换行
	4.break在循环体中，结束本层循环；continue，结束本次循环体内容，跳过后面的语句，继续下一次循环。
	如果一个循环内的continue前面没有语句，后面就不能跟语句，否则编译会报错；
	5.函数定义好后，需要调用后才会被执行；main函数是由jvm调用，不需要我们手动调用
	6.如果一个函数的返回值类型是确定的，就必须保证在任意情况下都必须有该类型的返回值，除了void
	7.如果一个函数一旦执行到了return关键字，那么该函数就马上结束；一个函数的返回值类型是void，是可以出现return关键字，但是			return后面不能跟数据
	8.重载:方法名相同，参数列表不同，与函数的返回值类型是无关的
	9.数组是同一种数据类型的集合容器
	10.栈内存：存储的都是局部变量，变量一旦出了自己的作用域，马上会从内存中消失，释放内存空间
	11.堆内存：存储的都是对象数据，对象一旦使用完，并不会马上从内存中消失，而是等待垃圾回收器不定时把垃圾对象回收，这时候对象	
	才会消失，释放内存；凡是以new关键字创建的对象，jvm都会在堆内存中开辟一块新的空间创建一个新的对象
	12.没有引用数据变量指向的对象就是垃圾对象
day_3:
	1.冒泡排序：相邻两个元素依次比较，符合条件交换位置；直接排序：一个元素与其他每个元素进行比较
	2.Arrays.toString遍历数组
	3.数组中元素与元素之间的内存地址是连续的
day_4:
	1.成员变量随着对象的创建而创建，随着对象的消失而消失；局部变量在调用了对应的方法时执行到创建该变量的语句的时候存在，局部		变量一旦出了自己的作用域就马上从内存中消失
	2.成员变量是有默认的初始值的，局部变量是没有初始值的，必须先初始化才能使用
	3.没有引用变量指向的对象是匿名对象，匿名对象的属性是无法获取到的
	4.构造函数与类名一致，没有返回值，也不能写void；构造函数的作用是：给对应的对象初始化；构造函数并不是我们手动调用的，jvm会		主动调用对应的构造函数；如果没有显示的写出构造函数，Java编译器会为该类添加一个无参的构造函数；如果显示写出，编译器就不会		添加无参构造器;构造器的权限与对应的类的权限一致；构造函数可以在一个类中以重载的形式存在
	5.构造代码块：大括号位于成员变量的位置，给对象统一的进行初始化
	Java编译器编译的时候，会把成员变量的声明语句提前至一个类的最前端；经过Java编译器编译后，构造代码块的代码会被放到构造函数		中执行，构造函数的代码最后执行；成员变量的显示初始化与构造代码块的初始化是按照代码的顺序进行编译的；
	6.this：代表所属函数的调用者对象； 成员变量与局部变量同名时，就进原则；如果在一个方法中访问一个变量，只有成员变量的时候，		Java编译器会在该变量前面加上this关键字
	7.一个函数的形式参数也是属于局部变量；同名的成员变量与局部变量，在方法内部默认使用局部变量
	8.静态代码块：它所属的类加载到内存的时候运行，只运行一次
day_5:
	1.this关键字调用其他构造器的时候，必须位于构造函数第一句；this关键字不能在构造函数中相互调用
	2.static：静态的成员变量，只会在数据共享区中维护一份，而非静态成员变量的数据会在每个对象中都维护一份；可以使用类名.访问
	静态的成员函数也可以类名.调用；静态的函数不能直接访问非静态的成员；非静态的函数可以直接访问静态与非静态的成员(方法和变			量)；静	态函数不能出现this和super关键字(非静态的变量随着对象的创建而存在，而静态的成员在对象存在前就已经存在了)
	3.一个函数如果没有直接访问非静态成员是，可以使用static修饰，一般用于工具类
	4.mian：不是关键字，只不过是jvm能识别的一个特殊的函数名而已
	5.父类私有的成员子类不能继承；父类的构造方法子类不能继承；创建子类对象时默认先调用父类的无参构造函数
	6.super：代表了父类空间的引用；子父类存在同名的成员时，在子类中默认访问子类的成员，可以通过super关键字指定访问父类的成员
	如果在子类的构造方法中没有调用父类的构造方法，编译器会在子类的构造方法上面加上super（）语句；
	super关键字调用父类构造方法时，必须在子类构造函数的第一句；super与this关键字不能同时出现在同一个构造函数中调用其他构造器
	7.重写：子类的方法与父类的方法的名字和形参列表必须一致，并且子类的权限修饰符大于或等于父类的权限修饰符；子类的返回值类型		必须小于或等于父类的返回值类型；子类抛出的异常类型要小于或等于父类抛出的异常类型
	8.单例设计模式：保证一个类在内存中只有一个对象
day_6:	
	1.instanceof:(必须要存在继承或实现的关系)判断一个对象是否属于指定的类别；
	2.final:修饰一个基本类型的成员变量时，为常量，一般用public static final修饰，该变量不能被重新赋值，并且必须在声明的时候赋		初始值；修饰引用类型变量时，该变量不能重新指向新的对象；修饰函数的时候，不能被重写；修饰类，不能被继承
	3.abstract：abstract修饰的方法的类必须是抽象类；一个非抽象类继承抽象类，必须实现全部的抽象方法；；抽象类不能创建对象；抽		象类有构造方法；abstract不能与private、static、final修饰同一个方法；
	4.如果是不同的引用变量操作同一个对象，那么肯定会影响结果
	5.interface：是一个特殊的类；成员变量默认修饰符public static final，即常量；成员方法默认修饰符为public abstract；不能创建		对象；没有构造方法的；非抽象类实现一个接口，必须实现接口中的所有方法；抽象类实现一个接口时，可以不实现接口中的所有方法；
	接口之间是可以多继承的；
	6.多态：一个对象具有的多种状态。(父类的引用类型变量指向了子类的对象或接口的引用类型变量指向了接口实现类的对象)
	多态情况下：子父类存在同名成员变量时，访问的是父类的；子父类存在同名的非静态函数时，访问的是子类的；子父类存在同名的静态		函数时，访问的是父类的；不能访问子类特有的成员。(子父类存在同名的成员时，访问的是父类的，只有在同名非静态函数时才是访问子		类的)
day_7:
	1.接口之间的多态情况下，都是调用实现类的
	2.内部类：成员内部类、局部内部类；内部类可以直接访问外部类的所有成员；在内部类可以用外部类.this.外部类成员变量调用外部类		的成员变量；成员内部类一旦出现静态的成员，该类也必须是static修饰的静态类；局部内部类访问局部变量，该变量必须用final修饰
	3.匿名内部类：前提是要存在继承或是实现关系
day_8
	1.throwable:exception(异常)(需要通过代码去处理)和error（错误）(一般由于jvm或硬件引发的问题，一般不需要代码去处理)的超类；
	2.exception：运行时异常和编译时异常
	3.如果try块中出现了异常，try里面的异常代码后面的代码将不会执行；捕获的异常类型必须从小到大，否则编译报错
	4.如果一个方法内抛出了一个异常对象，throw语句后面的代码不会再执行，一种情况，只能抛出一种异常
day_9:
	1.自定义异常：继承exception；	
	2.如果一个方法内部抛出了一个运行时异常，那么方法可以声明也可以不声明，调用者也可以不进行或不进行处理；如果一个方法内部抛		出了一个编译时异常，那么方法上就必须要声明，而且调用者必须处理
	3.finally：存在try块才能使用，其中的代码在任何情况下都会执行，除了jvm退出
day_10:
	1.package：必须位于Java文件中的第一个语句；如果一个类加上了包语句，那么这个类的完整路径是 包名.类名；一个Java文件对应一个		包语句；导包语句:import 包名.类名(如果有多个同包类，可以使用"*"，"*"只能匹配类名，但不能匹配它的子包)java.lang包默认导入
	2.public>protected>default>private
day_11:
	1.模板模式：先写出解决该类事情的一件解决方案，分析代码，把会发生变化的代码抽取出来独立成一个方法
	2.object类是所有类的根类
	3.按ctrl键单击要查看的源代码
	4.String类重写了object的equals方法，比较的是两个字符串对象的内容是否一致
	5.字节数组、字符数组和字符串是可以相互转换的
	6.字符串是常量，它的值在创建后不能改变；字符串的内容一旦发生了变化，那么会创建一个新的对象
day_12:
	1.StringBuffer与StringBuilder：都是字符串缓冲类，StringBuffer是线程安全的，操作效率低，StringBuilder是线程非安全的，效率		高；StringBuffer是jdk1.0出现的，StringBuilder是jdk1.5出现的
	2.进程：正在执行的程序称为一个进程，负责了内存空间的划分
	3.线程：在一个进程中负责了代码的执行；在一个进程中可以有多个线程执行不同的任务
	4.不要手动调用run()方法，不然就是普通方法的调用，调用start()方法的时候，线程默认会调用run()方法
day_13:
	1.Thread类的子类不能在重写的run方法中抛出异常，只能捕获；
	2.sleep()是静态的方法，哪个线程执行了此方法代码，哪个线程睡眠
	3.线程安全问题：存在多个线程对象，之间共享一个资源(static)，有多个语句操作了共享资源
	死锁：存在多个线程和多个共享资源
	4.synchronized:
	同步代码块：任何一个对象都可以作为锁对象,但必须是唯一共享的；注意要有static共享的数据，在里面的sleep（）方法并不会释放锁		，存在线程安全问题时使用，否则效率会降低；  
	同步函数：如果是一个非静态的同步函数的锁，对象是this对象，如果是静态的同步函数的锁，对象是当前函数所属的类的字节码文件			(class对象)，锁是固定的，不能由我们指定；如果要使用的话，也必须保证对象是唯一共享的
	5.注意main方法也是一个线程
day_14:
	1.wait和notify都属于object对象的，必须在同步代码块或函数中使用，也必须由锁对象调用；调用wait会释放锁，建立一个以锁对象为		标识符的线程池，调用notify唤醒以锁对象为标识符的线程池其中一个等待的线程；notifyAll唤醒线程池中所有等待的线程
	2.interrupt()：停止一个等待状态下的线程
	3.daemon：一个进程只剩下了守护线程(后台线程)，守护线程也会死亡
	4.join()：执行该语句的线程必须让步新加入的线程执行完毕，才继续执行自己的线程
	5.collection(单列集合的根接口)：实现set接口的集合类，无序不能重复、实现list接口的实现类有序可重复
	6.从object数组中取出的元素只能用object类型声明变量接收，如果需要其它的类型需要进行强制类型转换
	7.iterator：迭代器，用于抓取集合元素
day_15:
	1.有序：添加进去的顺序和出来的顺序是一致的
	2.在迭代器迭代元素的过程中，不允许使用集合对象改变集合中元素的个数，如果需要改变只能使用迭代器的方法进行操作；
	3.ArrayList：默认容量10，不够增长0.5倍；底层维护的是object数组，查询快，增删慢，jdk1.2出现的
	4.集合对象的contains方法底层维护的是equals方法，(需要时重写equals方法)
	5.LinkedList：使用链表数据结构实现的，查询速度慢，增删快
	6.堆栈数据结构存储特点：先进后出，后进先出；队列数据结构存储特点：先进先出，后进后出
	7.vector：底层维护的object数组，线程安全的，被ArrayList取代，jdk1.0出现的
	8.hashset:底层使用了哈希表来支持的，存取速度快。添加一个对象作为元素的时候，hashset会先调用元素的hashcode方法得到的哈希码		值，然后通过元素的哈希码值经过位移等运算，就可以算出该元素在哈希码表中的存位置。如果该位置没有元素，可以存储；有元素，还会		调用该元素的equals方法进行比较，返回false,可以存储
	9.String类已经重写了object的hashcode方法，如果内容一致，返回的哈希码值一定一样
	10.treeset:(原理：红黑树或二叉树)添加的元素具备自然顺序，就按照该特征排序；否则，必须实现comparable接口，定义比较规则，如		果compareto方法返回的是	0，就视为重复元素，不会被添加进去；或者创建treeset的时候传入一个比较器(一个类实现comparetor接口，		把元素的比较规则写在compare方法里)；如果两种方法都有了，优先使用比较器的。(String类已经重写了comparto方法)
day_16:
	1.泛型：没有多态的概念，左右两边要么一致，要么只写一边；不能使用基本数据类型，而是使用它们的封装类
	2.自定义泛型：一个数据类型的占位符或者是一个数据类型的变量；在类上定义的泛型的具体类型是在该类创建对象的时候确定的，如果在		类上自定义了泛型，使用该类创建的对象时没有指定具体类型，默认是object类型；在类上自定义的泛型不能作用于静态方法，可以在该方		法上声明使用；在接口上使用，如果它的实现类没有指定，默认是object类型的，如果等待它的子类对象创建的时候再确定，那么在它的子		类上还要声明
	3.泛型的上下限：上限：<? extends 数据类型> ，下限： <? super 数据类型>
day_17:
	1.map:(双列集合)实现map接口的集合类，存储的数据都是键值对的形式，键不可重复，值可以重复
	2.hashmap:底层也是基于哈希表实现的，添加元素的时候会调用键的hashcode方法，同hashset，如果是重复的，那么之前的值会被替换
	3.treemap:基于红黑树(二叉树)数据结构，对元素的键进行排序；如果添加的元素的键没有自然顺序，同treeset
	4.hashtable：底层也是依赖哈希表实现的，和hashmap一致，是线程安全的，效率低，已经被hashmap取代了(jdk1.0)
	5.collections:集合工具类，(集合和数组可以相互转换)
	6.断点模式：双击某一行代码，选择DeBugAs
	7.正则表达式：用来操作字符串的一个规则，使用了特殊的符号表示(正则对象pattern，匹配器matcher)
day_18:
	1.静态导入：(简化书写)如果导入的静态类的方法和本类的方法同名时，只会调用本类的方法  jdk1.5
	2.foreach: 增强for循环，底层还是使用的迭代器，实现了iterable接口的对象和数组对象可以使用，里面不能使用集合对象改变个数	
	3.iterable：是单列集合的超级接口
	4.可变参数：(格式：)数据类型...  变量名 ,实际上也是数组 ，必须位于形参中的最后一个，因此一个方法最多只有一个可变参数
	5.自动装箱：把基本类型数据转换成引用类型；自动拆箱：把引用类型数据转换成基本类型  jdk1.5
	6.integer:内部存在存储-128-127之间的数据的数组，如果不够用，就创建新的
	7.枚举：一个特殊的类，解决一些方法运行时，需要的数据不是任意的，而是有一定的范围;
	8.枚举值：默认修饰符public static final，枚举值就是枚举值所属的类的类型，枚举值是指向本类的对象的
	9.枚举类：默认构造器是private修饰，可以自定义，但修饰符也必须是private，枚举值也必须要进行初始化；可以有自定义的成员；可以		写抽象方法，但枚举值必须实现抽象方法；枚举值必须是枚举类的第一个语句
day_19:
	1.IO流：字节流：读取的都是二进制数据；字符流：读取的也是二进制数据，然后把这些二进制数据转换成以字符为单位的字符；注意关闭		资源：先开后关，后开先关
	2.fileinputstream:读取的缓冲数组的内容是覆盖前一次的内容
	3.fileoutputstream:write方法写数据的时候，虽然接收的是int类型的，但真正写出的是一个字节，只是把低八位的二进制写出，其他二		十四位数据全部丢弃
	4.bufferinputstream：本身不具备读写能力，调用它的close()方法实际上关闭的是传入的输入流；内部维护了8kb的字节数组,
	bufferoutputstream:它的write方法是先写到8kb的字节数组里，如果没写满，调用flush方法或者close方法才把数据真正写出去
	5.filewriter:它的write方法内部维护了1kb的字符数组，先写到数组里，如果没写满，调用flush方法或者close方法才把数据真正写出去
	6.bufferreder:本身不具备读写的功能，内部维护了8kb的字符数组，提高了效率，并且还拓展了功能
	7.bufferwrite:内部提供了8kb的字符数组，提高了效率，拓展了功能，如果没写满，调用flush方法或者close方法才把数据真正写出去
	8.装饰者设计模式(增强一个类的功能)：有一个共同的父类(即被增强的类)父类和一些装饰的类(有一个共同的变量指向父类)，这些装饰类		之间就可以相互装饰(多态)了
	9.SequenceInputStream：序列流，参数需要vector的Enumeration或者2个输入流
day_20:
	1.objectoutputstream:实现了Serializable(序列化)标志接口(没有任何方法的接口)的类的对象才能被写出
	2.反序列化：就是读取信息，对象的反序列化不会调用此对象的构造方法
	3.如果序列化对象后，又对类的成员进行了修改，那么反序列化就会有问题。解决：在这个类里指定一个serialVersionUID即可
	4.transient修饰的变量不会被序列化出去
	5.Properties：用于生成或加载配置文件的一个类(继承hashtable)
	6.printstream:打印流，可以接收任意类型的数据，然后把数据转换成String,再打印出去；还可以收集日志信息
	7.平台默认是gbk码表，编码与解码注意统一，否则中文可能会出现乱码；编码或解码的时候指定的码表是Unicode，实际上用的是utf-16,		用它会在前面加上-2和-1两个字节作为标志
	8.in(out)putstreamreader：字节流转换成字符流，还可以指定用的码表
	9.递归：方法自身调用自身，前提必须要有条件，不然就是死循环
	10.ip地址(共32位，分成4组)= 网络号+主机号。协议：udp和tcp
	11.InetAddress：ip类
	12.端口号：0-65535(2的16次方个)，0-1023已经被系统紧密绑定了
	13.udp:将数据封装为数据包，面向无连接：每个数据包大小限制64k，因为不需要建立连接，所以速度快，不可靠，用于游戏等
	14.tcp:面向连接，有特有的通道，可以在连接中传输(基于IO流)大数据，通过三次握手机制，可靠协议，通讯前必须建立连接，效率稍低
	15.在udp中，主机号是255的是广播地址，即给同一个网络号发送信息，此网络号内的所有用户都会收到消息；如果用upd传输数据，当cpu		处理不过来时，就会放在cpu的寄存器里，大小为1kb，后面的内容就丢失了
day_21:
	1.tcp:通过三次握手机制检查连接是否畅通，然后再进行数据传输；分客户端和服务端，客户端一旦启动，马上要与服务端进行连接
	2.浏览器和服务器之间也是用的tcp协议，浏览器就是客户端
day_22:
	1.java.awt包的图形类都是依赖于系统的图形库	
	2.java.swing包的图形类都是sun自己实现的，不需要依赖系统的图形库
day_23:
	1.bet批处理文件：一次可以执行多个命令的文件
	2.对象克隆：浅克隆：被克隆的类要实现cloneable(标识)接口,没有方法，注意重写clone方法，可以改权限修饰符，如果被克隆的类还维	        护了另一个类的对象，那么只是克隆的那个对象的内存地址，没有把那个对象也克隆一份，克隆不会调用对象的构造方法；
	深克隆：实际上是用的对象流，先把被克隆的对象写出去，在用需要克隆对象的对象去读取
	3.不再使用的对象应该不要让变量指向该对象，让垃圾回收器尽快去回收
	4.低耦合：不要让一个类过分依赖于另一个类
	5.观察者模式
	6.反射：当一个字节码文件加载到内存的时候，jvm会对该字节码文件进行解剖，然后创建一个对象的Class对象，把字节码的文件信息全部		都存储到该Class对象中，只要获取到Class对象，就可以使用字节码对象设置对象的属性或者调用对象的方法等操作
	7.工厂模式：用反射返回一个对象，然后用一个对象来接收，即所需的对象
day_24:
	1.Junit：单元测试，在需要测试的方法上加@Test,就是测试方法了，也可以使用断言测试；测试的方法不能是静态的和有形参的
	@Before：一个测试方法运行前运行一次；@BeforeClass：所有测试方法运行前运行一次，此方法还必须是静态的
	2.内省：变态的反射，用于封装类中，把对象的属性数据封装到对象中
	3.beanutils：底层依赖于get和set方法，如果设置的是基本数据类型，把设置的属性自动转换成String类型，如果设置的是引用类型的数		据类型，需要注册一个类型转换器
	4.类文件路径：类名.class.getResourceAsStream，里面的路径用/间隔

	泛型擦除，泛型只在编译时期有效，编译后的字节码文件中不存在有泛型信息！